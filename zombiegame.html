<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Survivor</title>
    <link rel="stylesheet" href="zstyle.css">
</head>
<body>
 <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="gameUI">
            <div>Health: <span id="health">100</span></div>
            <div>Score: <span id="score">0</span></div>
            <div>Stage: <span id="wave">1</span></div>
            <div>Player Level: <span id="level">1</span></div>
            <div>XP: <span id="xp">0/100</span></div>
            <div>Money: $<span id="currency">0</span></div>
            <div>Weapon: <span id="currentWeaponName">Pistol</span></div>
            <div>Zombies: <span id="zombieCount">0</span></div>
            <div>Tools: <span id="playerTools">X N:0 W:0</span></div>
            <div id="difficultyDisplay" style="color: #ffaa00; font-size: 8px; font-weight: bold;">NORMAL MODE</div>
            <div style="color: #888; font-size: 8px; margin-top: 4px;">WASD: Move | T: Auto | B: Store | R: Walls</div>
            <div style="color: #00ff00; font-size: 8px;">Auto: <span id="autoTargetStatus">ON</span></div>
        </div>
        <button id="pauseButton" onclick="togglePause()">‚è∏</button>
        <button id="companionButton" onclick="buyCompanion()">+ Add Ally ($100)</button>
        <button id="fullscreenButton" onclick="toggleFullscreen()">‚õ∂</button>
        
        <!-- Mobile Touch Controls -->
        <div id="mobileControls" style="display: none;">
            <div id="virtualJoystick">
                <div id="joystickBase">
                    <div id="joystickKnob"></div>
                </div>
            </div>
            <div id="mobileActionButtons">
                <button class="mobile-btn" id="mobileShootBtn">üî´</button>
                <button class="mobile-btn" id="mobileAutoBtn">üéØ</button>
                <button class="mobile-btn" id="mobileStoreBtn">üè™</button>
                <button class="mobile-btn" id="mobileWallBtn">üß±</button>
                <button class="mobile-btn" id="mobilePauseBtn">‚è∏Ô∏è</button>
            </div>
        </div>
        
        <div id="startMenu">
            <div class="start-menu-content">
                <h1 class="game-title">ZOMBIE SURVIVOR</h1>
                <div class="subtitle">üßü Defend the Sanctuary üßü</div>
                
                <div class="difficulty-selection">
                    <h3>üéöÔ∏è SELECT DIFFICULTY</h3>
                    <div class="difficulty-buttons">
                        <button onclick="startNewGame('easy')" class="difficulty-button easy-mode">
                            üòä EASY MODE
                            <div class="difficulty-desc">Relaxed gameplay, forgiving stats</div>
                        </button>
                        <button onclick="startNewGame('normal')" class="difficulty-button normal-mode">
                            üéØ NORMAL MODE
                            <div class="difficulty-desc">Balanced challenge for most players</div>
                        </button>
                        <button onclick="startNewGame('hardcore')" class="difficulty-button hardcore-mode">
                            üíÄ HARDCORE MODE
                            <div class="difficulty-desc">Brutal survival challenge</div>
                        </button>
                    </div>
                </div>
                
                <div class="menu-options">
                    <button onclick="showHighScores()" class="menu-button">üèÜ HIGH SCORES</button>
                    <button onclick="showInstructions()" class="menu-button">üìñ HOW TO PLAY</button>
                </div>
                
                <div class="game-description">
                    <p>Survive endless waves of zombies while defending your sanctuary. Use weapons, build walls, and hire allies to stay alive as long as possible!</p>
                </div>
                
                <div class="version-info">v1.0 - Hardcore Edition</div>
            </div>
        </div>
        
        <div id="pauseOverlay">
            <div class="pause-title">PAUSED</div>
            <div class="how-to-play">
                <h3>üéÆ HOW TO PLAY</h3>
                
                <div class="controls-section">
                    <h4>‚å®Ô∏è Controls</h4>
                    <div class="control-grid">
                        <div><strong>WASD</strong> - Move Player</div>
                        <div><strong>Mouse</strong> - Aim & Auto-fire</div>
                        <div><strong>T</strong> - Toggle Auto-targeting</div>
                        <div><strong>B</strong> - Open/Close Store</div>
                        <div><strong>R</strong> - Rebuild Walls (need tools)</div>
                        <div><strong>P / ESC</strong> - Pause Game</div>
                        <div><strong>F11</strong> - Toggle Fullscreen</div>
                        <div><strong>F</strong> - Skip Level 7 (if stuck)</div>
                        <div><strong>Mouse Wheel</strong> - Scroll in Store</div>
                    </div>
                </div>

                <div class="gameplay-section">
                    <h4>üéØ Objective</h4>
                    <p>Survive waves of zombies while defending the sanctuary. Kill zombies to gain XP, level up, and earn money to buy better weapons and supplies.</p>
                </div>

                <div class="systems-section">
                    <h4>üõ†Ô∏è Game Systems</h4>
                    <div class="system-grid">
                        <div><strong>üè™ Store:</strong> Buy weapons, tools, and supplies</div>
                        <div><strong>üß± Walls:</strong> Protect sanctuary from zombies</div>
                        <div><strong>üë• Allies:</strong> Hire companions to help fight</div>
                        <div><strong>üîß Tools:</strong> Hammer, nails, wood to repair walls</div>
                        <div><strong>‚ö° Safe Zone:</strong> Heal inside the sanctuary</div>
                        <div><strong>üéØ Auto-Target:</strong> Automatically aims at nearest zombie</div>
                    </div>
                </div>

                <div class="tips-section">
                    <h4>üí° Tips</h4>
                    <ul>
                        <li>Stay in the sanctuary to heal</li>
                        <li>Buy tools early to repair walls</li>
                        <li>Higher level weapons unlock as you progress</li>
                        <li>Allies help but cost money to maintain</li>
                        <li>Use mouse wheel to scroll through all weapons in store</li>
                        <li>Some weapons have special abilities (pierce, explosive, etc.)</li>
                    </ul>
                </div>
                
                <div class="pause-buttons">
                    <button onclick="togglePause()">Resume Game</button>
                    <button onclick="quitGame()" class="quit-button">Quit to Menu</button>
                    <a href="index.html" class="home-button">‚Üê Back to Website</a>
                </div>
            </div>
        </div>
        <div id="gameOver">
            <h2 id="gameOverMessage">Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Survived: <span id="finalWave">0</span></p>
            <div id="newHighScore" style="display: none;">
                <h3>üéâ NEW HIGH SCORE! üéâ</h3>
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                <button onclick="saveHighScore()">Save Score</button>
            </div>
            <button onclick="restartGame()">Play Again</button>
            <button onclick="showHighScores()">View High Scores</button>
            <button onclick="returnToMenu()" class="menu-button">Return to Menu</button>
        </div>

        <div id="highScoresModal" style="display: none;">
            <div class="modal-content">
                <h2>üèÜ HIGH SCORES üèÜ</h2>
                <div id="highScoresList"></div>
                <button onclick="closeHighScores()">Close</button>
                <button onclick="clearHighScores()">Clear All Scores</button>
                <button onclick="returnToMenu()" class="menu-button">Return to Menu</button>
            </div>
        </div>
    </div>

    <script src="zscript.js"></script>
    <script>
        // Mobile Detection and Controls Initialization
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        }

        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize mobile controls if on mobile device
            if (isMobileDevice()) {
                document.getElementById('mobileControls').style.display = 'block';
                
                // Virtual Joystick Touch Handler
                let joystick = {
                    active: false,
                    touchId: null,
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    deltaX: 0,
                    deltaY: 0,
                    normalizedX: 0,
                    normalizedY: 0
                };

                const joystickBase = document.getElementById('joystickBase');
                const joystickKnob = document.getElementById('joystickKnob');
                const maxDistance = 50; // Increased for better control

                // Joystick touch start
                joystickBase.addEventListener('touchstart', function(e) {
                    // Only prevent default on the joystick itself, not globally
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (joystick.active) return; // Already active
                    
                    const touch = e.touches[0];
                    joystick.active = true;
                    joystick.touchId = touch.identifier;
                    
                    const rect = joystickBase.getBoundingClientRect();
                    joystick.startX = rect.left + rect.width / 2;
                    joystick.startY = rect.top + rect.height / 2;
                    
                    // Visual feedback
                    joystickBase.style.opacity = '0.8';
                }, { passive: false });

                // Joystick touch move - only listen on the document to track properly
                document.addEventListener('touchmove', function(e) {
                    if (!joystick.active) return;
                    
                    // Find our specific touch
                    let ourTouch = null;
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === joystick.touchId) {
                            ourTouch = e.touches[i];
                            break;
                        }
                    }
                    
                    if (!ourTouch) return;
                    
                    // Only prevent default for joystick movement - check if touch is near joystick area
                    const joystickRect = joystickBase.getBoundingClientRect();
                    const touchDistance = Math.sqrt(
                        Math.pow(ourTouch.clientX - (joystickRect.left + joystickRect.width/2), 2) + 
                        Math.pow(ourTouch.clientY - (joystickRect.top + joystickRect.height/2), 2)
                    );
                    
                    // Only prevent default if touch is within reasonable distance of joystick
                    if (touchDistance < 150) {
                        e.preventDefault();
                    }
                    
                    const deltaX = ourTouch.clientX - joystick.startX;
                    const deltaY = ourTouch.clientY - joystick.startY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance <= maxDistance) {
                        joystick.deltaX = deltaX;
                        joystick.deltaY = deltaY;
                    } else {
                        const angle = Math.atan2(deltaY, deltaX);
                        joystick.deltaX = Math.cos(angle) * maxDistance;
                        joystick.deltaY = Math.sin(angle) * maxDistance;
                    }
                    
                    // Normalize values for game use (-1 to 1)
                    joystick.normalizedX = joystick.deltaX / maxDistance;
                    joystick.normalizedY = joystick.deltaY / maxDistance;
                    
                    // Update visual position
                    joystickKnob.style.transform = `translate(-50%, -50%) translate(${joystick.deltaX}px, ${joystick.deltaY}px)`;
                }, { passive: false });

                // Joystick touch end
                document.addEventListener('touchend', function(e) {
                    if (!joystick.active) return;
                    
                    // Check if our touch ended
                    let touchEnded = true;
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === joystick.touchId) {
                            touchEnded = false;
                            break;
                        }
                    }
                    
                    if (touchEnded) {
                        joystick.active = false;
                        joystick.touchId = null;
                        joystick.deltaX = 0;
                        joystick.deltaY = 0;
                        joystick.normalizedX = 0;
                        joystick.normalizedY = 0;
                        
                        // Reset visual position
                        joystickKnob.style.transform = 'translate(-50%, -50%)';
                        joystickBase.style.opacity = '1';
                    }
                });

                // Mobile Button Event Listeners with better touch handling
                function addMobileButtonListener(buttonId, callback) {
                    const button = document.getElementById(buttonId);
                    if (button) {
                        button.addEventListener('touchstart', function(e) {
                            // Only prevent default on our mobile control buttons, not globally
                            e.preventDefault();
                            e.stopPropagation();
                            this.style.transform = 'scale(0.9)';
                            callback();
                        }, { passive: false });
                        
                        button.addEventListener('touchend', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this.style.transform = 'scale(1)';
                        }, { passive: false });
                    }
                }

                // Add button listeners
                addMobileButtonListener('mobileShootBtn', function() {
                    if (typeof window.mobileShoot === 'function') window.mobileShoot();
                });

                addMobileButtonListener('mobileAutoBtn', function() {
                    // Try different possible function names for auto-target
                    if (typeof toggleAutoTarget === 'function') {
                        toggleAutoTarget();
                    } else if (typeof window.toggleAutoTarget === 'function') {
                        window.toggleAutoTarget();
                    } else {
                        // Simulate 'T' key press
                        const event = new KeyboardEvent('keydown', { key: 'T', keyCode: 84 });
                        document.dispatchEvent(event);
                    }
                });

                addMobileButtonListener('mobileStoreBtn', function() {
                    // Try different possible function names for store
                    if (typeof toggleStore === 'function') {
                        toggleStore();
                    } else if (typeof window.toggleStore === 'function') {
                        window.toggleStore();
                    } else {
                        // Simulate 'B' key press
                        const event = new KeyboardEvent('keydown', { key: 'B', keyCode: 66 });
                        document.dispatchEvent(event);
                    }
                });

                addMobileButtonListener('mobileWallBtn', function() {
                    // Try different possible function names for walls
                    if (typeof rebuildWalls === 'function') {
                        rebuildWalls();
                    } else if (typeof window.rebuildWalls === 'function') {
                        window.rebuildWalls();
                    } else {
                        // Simulate 'R' key press
                        const event = new KeyboardEvent('keydown', { key: 'R', keyCode: 82 });
                        document.dispatchEvent(event);
                    }
                });

                addMobileButtonListener('mobilePauseBtn', function() {
                    if (typeof togglePause === 'function') {
                        togglePause();
                    } else if (typeof window.togglePause === 'function') {
                        window.togglePause();
                    }
                });

                // Export joystick state for game to use
                window.mobileJoystick = joystick;
                
                // Add helper function to check if joystick is being used
                window.getMobileInput = function() {
                    return {
                        x: joystick.normalizedX,
                        y: joystick.normalizedY,
                        active: joystick.active
                    };
                };

                // Simulate keyboard input based on joystick movement
                let currentKeys = { w: false, a: false, s: false, d: false };
                
                function updateMovementKeys() {
                    if (!joystick.active) {
                        // Release all keys when joystick is not active
                        if (currentKeys.w || currentKeys.a || currentKeys.s || currentKeys.d) {
                            releaseAllMovementKeys();
                        }
                        return;
                    }

                    const threshold = 0.3; // Dead zone threshold
                    const newKeys = {
                        w: joystick.normalizedY < -threshold, // Up
                        s: joystick.normalizedY > threshold,  // Down
                        a: joystick.normalizedX < -threshold, // Left
                        d: joystick.normalizedX > threshold   // Right
                    };

                    // Press/release keys as needed
                    for (let key in newKeys) {
                        if (newKeys[key] && !currentKeys[key]) {
                            // Press key
                            simulateKeyEvent('keydown', key);
                            currentKeys[key] = true;
                        } else if (!newKeys[key] && currentKeys[key]) {
                            // Release key
                            simulateKeyEvent('keyup', key);
                            currentKeys[key] = false;
                        }
                    }
                }

                function releaseAllMovementKeys() {
                    for (let key in currentKeys) {
                        if (currentKeys[key]) {
                            simulateKeyEvent('keyup', key);
                            currentKeys[key] = false;
                        }
                    }
                }

                function simulateKeyEvent(type, key) {
                    const keyCode = { 'w': 87, 'a': 65, 's': 83, 'd': 68 }[key];
                    const event = new KeyboardEvent(type, {
                        key: key.toUpperCase(),
                        code: `Key${key.toUpperCase()}`,
                        keyCode: keyCode,
                        which: keyCode,
                        bubbles: true,
                        cancelable: true
                    });
                    document.dispatchEvent(event);
                }

                // Update movement keys continuously
                setInterval(updateMovementKeys, 16); // ~60 FPS updates

                // Alternative: Direct movement injection for games that check keys object
                window.mobileMovement = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    updateFromJoystick: function() {
                        const threshold = 0.3;
                        this.up = joystick.active && joystick.normalizedY < -threshold;
                        this.down = joystick.active && joystick.normalizedY > threshold;
                        this.left = joystick.active && joystick.normalizedX < -threshold;
                        this.right = joystick.active && joystick.normalizedX > threshold;
                    }
                };

                // Update mobile movement state
                setInterval(function() {
                    window.mobileMovement.updateFromJoystick();
                }, 16);

                // Try to hook into common game key checking patterns
                const originalAddEventListener = document.addEventListener;
                document.addEventListener = function(type, listener, options) {
                    if (type === 'keydown' || type === 'keyup') {
                        // Wrap the listener to inject our mobile input
                        const wrappedListener = function(event) {
                            // Call original listener
                            listener(event);
                        };
                        return originalAddEventListener.call(this, type, wrappedListener, options);
                    }
                    return originalAddEventListener.call(this, type, listener, options);
                };
                
                // Add mobile store scrolling support
                let storeScrolling = {
                    startY: 0,
                    currentY: 0,
                    isScrolling: false,
                    touchId: null
                };

                // Check for store element and add touch scrolling
                function initializeStoreScrolling() {
                    // Try multiple approaches to find store elements
                    const storeSelectors = [
                        '#store', '.store', '[class*="store"]', '[id*="store"]',
                        '#shop', '.shop', '[class*="shop"]', '[id*="shop"]',
                        '.weapon-list', '.item-list', '.inventory',
                        '[class*="weapon"]', '[class*="item"]', '[class*="inventory"]'
                    ];
                    
                    let storeElement = null;
                    for (let selector of storeSelectors) {
                        storeElement = document.querySelector(selector);
                        if (storeElement) break;
                    }
                    
                    if (storeElement) {
                        // Add touch scrolling and item selection to store
                        storeElement.addEventListener('touchstart', function(e) {
                            if (storeScrolling.isScrolling) return;
                            // Don't stop propagation to allow normal interactions
                            
                            const touch = e.touches[0];
                            storeScrolling.isScrolling = true;
                            storeScrolling.touchId = touch.identifier;
                            storeScrolling.startY = touch.clientY;
                            storeScrolling.currentY = touch.clientY;
                            storeScrolling.touchStartTime = Date.now();
                            storeScrolling.moved = false;
                        }, { passive: true });

                        storeElement.addEventListener('touchmove', function(e) {
                            if (!storeScrolling.isScrolling) return;
                            
                            let ourTouch = null;
                            for (let i = 0; i < e.touches.length; i++) {
                                if (e.touches[i].identifier === storeScrolling.touchId) {
                                    ourTouch = e.touches[i];
                                    break;
                                }
                            }
                            
                            if (!ourTouch) return;
                            
                            const deltaY = ourTouch.clientY - storeScrolling.currentY;
                            
                            // Track if user has moved significantly (scrolling vs tapping)
                            if (Math.abs(deltaY) > 5) {
                                storeScrolling.moved = true;
                            }
                            
                            // Only scroll if movement is significant
                            if (Math.abs(deltaY) > 2) {
                                storeScrolling.currentY = ourTouch.clientY;
                                // Scroll the store content
                                this.scrollTop -= deltaY;
                            }
                        }, { passive: true });

                        storeElement.addEventListener('touchend', function(e) {
                            const touchEndTime = Date.now();
                            const touchDuration = touchEndTime - (storeScrolling.touchStartTime || 0);
                            
                            // If it was a quick tap without much movement, treat as item selection
                            if (!storeScrolling.moved && touchDuration < 300) {
                                const touch = e.changedTouches[0];
                                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                                
                                // Look for clickable store items (buttons, divs with click handlers, etc.)
                                let clickableItem = target;
                                let attempts = 0;
                                while (clickableItem && attempts < 5) {
                                    if (clickableItem.onclick || 
                                        clickableItem.getAttribute('onclick') ||
                                        clickableItem.classList.contains('item') ||
                                        clickableItem.classList.contains('weapon') ||
                                        clickableItem.classList.contains('store-item') ||
                                        clickableItem.tagName === 'BUTTON') {
                                        
                                        // Simulate click on the store item
                                        clickableItem.click();
                                        console.log('Store item clicked:', clickableItem);
                                        break;
                                    }
                                    clickableItem = clickableItem.parentElement;
                                    attempts++;
                                }
                            }
                            
                            storeScrolling.isScrolling = false;
                            storeScrolling.touchId = null;
                            storeScrolling.moved = false;
                        }, { passive: true });

                        console.log('Store touch scrolling initialized on:', storeElement);
                    } else {
                        console.log('No store element found, will retry...');
                        // Retry after a short delay if store not found yet
                        setTimeout(initializeStoreScrolling, 1000);
                    }
                }

                // Initialize store scrolling
                initializeStoreScrolling();

                // Add canvas touch scrolling and item selection for games that render store on canvas
                const canvas = document.getElementById('gameCanvas');
                if (canvas) {
                    let canvasScroll = {
                        startY: 0,
                        startX: 0,
                        isScrolling: false,
                        touchId: null,
                        inStoreArea: false,
                        touchStartTime: 0
                    };

                    canvas.addEventListener('touchstart', function(e) {
                        const touch = e.touches[0];
                        canvasScroll.startY = touch.clientY;
                        canvasScroll.startX = touch.clientX;
                        canvasScroll.touchId = touch.identifier;
                        canvasScroll.isScrolling = false;
                        canvasScroll.touchStartTime = Date.now();
                        
                        // Check if store is currently open
                        canvasScroll.inStoreArea = window.showStore || false;
                        
                        // If we can't access showStore, assume we might be in store for safety
                        if (canvasScroll.inStoreArea === undefined) {
                            setTimeout(() => {
                                canvasScroll.inStoreArea = true;
                            }, 50);
                        }
                        
                        console.log('Touch start - store open:', canvasScroll.inStoreArea);
                    }, { passive: true });

                    canvas.addEventListener('touchmove', function(e) {
                        if (!canvasScroll.inStoreArea) return;
                        
                        let ourTouch = null;
                        for (let i = 0; i < e.touches.length; i++) {
                            if (e.touches[i].identifier === canvasScroll.touchId) {
                                ourTouch = e.touches[i];
                                break;
                            }
                        }
                        
                        if (!ourTouch) return;
                        
                        const deltaY = ourTouch.clientY - canvasScroll.startY;
                        
                        if (Math.abs(deltaY) > 10) { // Minimum movement threshold
                            canvasScroll.isScrolling = true;
                            
                            // Only prevent default when in store and actually scrolling
                            if (window.showStore) {
                                e.preventDefault();
                                
                                // Simulate wheel events for canvas-based stores
                                const wheelEvent = new WheelEvent('wheel', {
                                    deltaY: -deltaY * 2, // Amplify and invert
                                    bubbles: true,
                                    cancelable: true
                                });
                                canvas.dispatchEvent(wheelEvent);
                            }
                            
                            canvasScroll.startY = ourTouch.clientY; // Reset for continuous scrolling
                        }
                    }, { passive: false });

                    canvas.addEventListener('touchend', function(e) {
                        const touchEndTime = Date.now();
                        const touchDuration = touchEndTime - canvasScroll.touchStartTime;
                        
                        // If touch was short (tap) and didn't scroll much, treat as item selection
                        if (!canvasScroll.isScrolling && touchDuration < 500 && canvasScroll.inStoreArea && window.showStore) {
                            e.preventDefault(); // Only prevent default when actually in store
                            
                            const touch = e.changedTouches[0];
                            const rect = canvas.getBoundingClientRect();
                            
                            // Calculate precise canvas coordinates
                            const scaleX = canvas.width / rect.width;
                            const scaleY = canvas.height / rect.height;
                            const canvasX = (touch.clientX - rect.left) * scaleX;
                            const canvasY = (touch.clientY - rect.top) * scaleY;
                            
                            console.log('Store touch at canvas coords:', canvasX, canvasY);
                            console.log('Store visible:', window.showStore);
                            
                            // Check if we're in store mode and call the purchase logic directly
                            if (window.showStore && window.weapons && window.playerCurrency !== undefined) {
                                // Store dimensions (matching the game's store layout)
                                const storeWidth = 900;
                                const storeHeight = Math.min(canvas.height - 40, 800);
                                const storeX = (canvas.width - storeWidth) / 2;
                                const storeY = (canvas.height - storeHeight) / 2;
                                
                                // Check if touch is within store area
                                if (canvasX >= storeX && canvasX <= storeX + storeWidth &&
                                    canvasY >= storeY && canvasY <= storeY + storeHeight) {
                                    
                                    // Calculate weapon list area
                                    const weaponStartY = storeY + 200; // Adjusted for supplies section
                                    const weaponHeight = 50;
                                    
                                    // Get available weapons
                                    const availableWeapons = Object.keys(window.weapons || {});
                                    
                                    // Group weapons by category
                                    const weaponCategories = {};
                                    availableWeapons.forEach(key => {
                                        const weapon = window.weapons[key];
                                        if (weapon && weapon.category) {
                                            if (!weaponCategories[weapon.category]) {
                                                weaponCategories[weapon.category] = [];
                                            }
                                            weaponCategories[weapon.category].push({key, ...weapon});
                                        }
                                    });
                                    
                                    let currentY = weaponStartY - (window.storeScrollY || 0);
                                    let itemFound = false;
                                    
                                    // Check each weapon category and item
                                    Object.keys(weaponCategories).forEach(category => {
                                        currentY += 20; // Category header space
                                        
                                        weaponCategories[category].forEach(weapon => {
                                            const weaponY = currentY;
                                            
                                            // Check if touch is on this weapon
                                            if (!itemFound && canvasX >= storeX + 20 && canvasX <= storeX + storeWidth - 20 &&
                                                canvasY >= weaponY - 5 && canvasY <= weaponY + weaponHeight - 5) {
                                                
                                                console.log('Weapon touched:', weapon.name, weapon.key);
                                                
                                                // Try to purchase weapon
                                                if (window.purchaseWeapon && typeof window.purchaseWeapon === 'function') {
                                                    window.purchaseWeapon(weapon.key);
                                                    console.log('Purchase function called for:', weapon.key);
                                                } else {
                                                    // Fallback: simulate exact mousedown event
                                                    const mouseDownEvent = new MouseEvent('mousedown', {
                                                        clientX: touch.clientX,
                                                        clientY: touch.clientY,
                                                        bubbles: true,
                                                        cancelable: true,
                                                        button: 0
                                                    });
                                                    canvas.dispatchEvent(mouseDownEvent);
                                                }
                                                
                                                itemFound = true;
                                                return;
                                            }
                                            
                                            currentY += weaponHeight + 3;
                                        });
                                        
                                        currentY += 5;
                                    });
                                    
                                    if (!itemFound) {
                                        console.log('No weapon found at touch position');
                                        // Still try simulating a mouse event as fallback
                                        const mouseDownEvent = new MouseEvent('mousedown', {
                                            clientX: touch.clientX,
                                            clientY: touch.clientY,
                                            bubbles: true,
                                            cancelable: true,
                                            button: 0
                                        });
                                        canvas.dispatchEvent(mouseDownEvent);
                                    }
                                }
                            } else {
                                // Fallback: simulate mouse events
                                const mouseDownEvent = new MouseEvent('mousedown', {
                                    clientX: touch.clientX,
                                    clientY: touch.clientY,
                                    bubbles: true,
                                    cancelable: true,
                                    button: 0
                                });
                                canvas.dispatchEvent(mouseDownEvent);
                            }
                        }
                        
                        canvasScroll.isScrolling = false;
                        canvasScroll.inStoreArea = false;
                        canvasScroll.touchId = null;
                    }, { passive: false });

                    console.log('Canvas touch scrolling initialized');
                }

                // Also add wheel event simulation for mobile
                function simulateWheelEvent(delta) {
                    const wheelEvent = new WheelEvent('wheel', {
                        deltaY: delta,
                        bubbles: true,
                        cancelable: true
                    });
                    
                    // Try to dispatch to store element or document
                    const storeElement = document.getElementById('store') || 
                                       document.querySelector('.store') ||
                                       document.querySelector('[class*="store"]') ||
                                       document.querySelector('[id*="store"]') ||
                                       document;
                    
                    storeElement.dispatchEvent(wheelEvent);
                }

                // Add swipe gesture support for store scrolling
                let swipeGesture = {
                    startY: 0,
                    threshold: 50, // minimum distance for swipe
                    restraint: 100, // maximum distance perpendicular to swipe direction
                    allowedTime: 300 // maximum time allowed to travel distance
                };

                document.addEventListener('touchstart', function(e) {
                    // Only handle if we're in the store area
                    const target = e.target.closest('#store, .store, [class*="store"], [id*="store"]');
                    if (!target) return;
                    
                    const touch = e.changedTouches[0];
                    swipeGesture.startY = touch.pageY;
                    swipeGesture.startTime = new Date().getTime();
                }, { passive: true });

                document.addEventListener('touchend', function(e) {
                    const target = e.target.closest('#store, .store, [class*="store"], [id*="store"]');
                    if (!target) return;
                    
                    const touch = e.changedTouches[0];
                    const distY = touch.pageY - swipeGesture.startY;
                    const elapsedTime = new Date().getTime() - swipeGesture.startTime;
                    
                    if (elapsedTime <= swipeGesture.allowedTime && Math.abs(distY) >= swipeGesture.threshold) {
                        // Simulate wheel scrolling based on swipe direction
                        const scrollAmount = distY > 0 ? -100 : 100; // Invert for natural scrolling
                        simulateWheelEvent(scrollAmount);
                    }
                }, { passive: true });

                // Add debugging for store state
                setInterval(() => {
                    if (window.showStore !== window.lastStoreState) {
                        console.log('Store state changed:', window.showStore);
                        window.lastStoreState = window.showStore;
                    }
                }, 1000);
                
                // Make sure game script variables are accessible globally  
                window.addEventListener('load', () => {
                    // Wait a bit for the game script to initialize
                    setTimeout(() => {
                        console.log('Game variables check:');
                        console.log('showStore:', typeof window.showStore);
                        console.log('weapons:', typeof window.weapons);
                        console.log('purchaseWeapon:', typeof window.purchaseWeapon);
                        console.log('playerCurrency:', typeof window.playerCurrency);
                    }, 2000);
                });
                
                // Add global touch-to-click handler for store items
                document.addEventListener('touchend', function(e) {
                    // Only handle if we're potentially in a canvas store
                    const touch = e.changedTouches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    
                    // Check if touching the canvas (which contains the store)
                    if (target && target.tagName === 'CANVAS' && target.id === 'gameCanvas') {
                        console.log('Canvas touched, store open:', window.showStore);
                        
                        // If store is open, the canvas touch handler will deal with it
                        if (window.showStore) {
                            return; // Let canvas handler deal with store touches
                        }
                    }
                    
                    // Check if the touch was on a regular HTML store-related element
                    if (target && (
                        target.closest('#store') || 
                        target.closest('.store') || 
                        target.closest('[class*="store"]') ||
                        target.closest('[id*="shop"]') ||
                        target.closest('.weapon-list') ||
                        target.closest('.item-list')
                    )) {
                        // Look for clickable elements
                        let clickable = target;
                        let depth = 0;
                        while (clickable && depth < 3) {
                            if (clickable.onclick || 
                                clickable.getAttribute('onclick') ||
                                clickable.tagName === 'BUTTON' ||
                                clickable.classList.contains('clickable') ||
                                clickable.hasAttribute('data-item') ||
                                clickable.hasAttribute('data-weapon')) {
                                
                                // Only prevent default for actual store interactions
                                if (clickable.closest('[class*="store"]') || clickable.closest('[id*="store"]')) {
                                    e.preventDefault();
                                }
                                
                                // Create and dispatch click event
                                const clickEvent = new MouseEvent('click', {
                                    bubbles: true,
                                    cancelable: true,
                                    clientX: touch.clientX,
                                    clientY: touch.clientY
                                });
                                clickable.dispatchEvent(clickEvent);
                                
                                console.log('Mobile HTML store item clicked:', clickable);
                                break;
                            }
                            clickable = clickable.parentElement;
                            depth++;
                        }
                    }
                }, { passive: false });

                console.log('Mobile controls with touch item selection initialized successfully');
            } else {
                // Hide mobile controls on desktop
                document.getElementById('mobileControls').style.display = 'none';
            }
        });

        // Mobile scrolling management - monitor pause state
        if (isMobileDevice()) {
            // Function to check if pause overlay is visible
            function checkPauseState() {
                const pauseOverlay = document.getElementById('pauseOverlay');
                const startMenu = document.getElementById('startMenu');
                const gameOver = document.getElementById('gameOver');
                const highScoresModal = document.getElementById('highScoresModal');
                
                const isPaused = (pauseOverlay && pauseOverlay.style.display !== 'none') ||
                               (startMenu && startMenu.style.display !== 'none') ||
                               (gameOver && gameOver.style.display !== 'none') ||
                               (highScoresModal && highScoresModal.style.display !== 'none');
                
                if (isPaused) {
                    document.body.classList.add('pause-active');
                } else {
                    document.body.classList.remove('pause-active');
                }
            }
            
            // Check pause state periodically
            setInterval(checkPauseState, 100);
            
            // Also check on DOM changes
            const observer = new MutationObserver(checkPauseState);
            observer.observe(document.body, {
                attributes: true,
                subtree: true,
                attributeFilter: ['style', 'class']
            });
            
            // Initial check
            setTimeout(checkPauseState, 500);
        }
    </script>
</body>
</html>










